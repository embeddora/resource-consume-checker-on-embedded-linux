#!/bin/bash
#
# Copyright (c) 2018 [n/a] info@embeddora.com All rights reserved
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#        * Redistributions of source code must retain the above copyright
#          notice, this list of conditions and the following disclaimer.
#        * Redistributions in binary form must reproduce the above copyright
#          notice, this list of conditions and the following disclaimer in the
#          documentation and/or other materials provided with the distribution.
#        * Neither the name of The Linux Foundation nor
#          the names of its contributors may be used to endorse or promote
#          products derived from this software without specific prior written
#          permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NON-INFRINGEMENT ARE DISCLAIMED.    IN NO EVENT SHALL THE COPYRIGHT OWNER OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# Abstract:           a script a) to prepare libraries in sustem '/usr/lib/..' 
#                     folder; b) to copy locally and rename two applications
#                     'gnome-system-monitor', 'htop', and to make them using libraries
#                     prepared in p. 'a', and to rename; c) to launch both these
#                     applications in respawn (e.g. auto-restert) mode.
#
# Usage:              from under user 'root' execute 'launcher.sh' on command line.
#                     To stop execute 'killall launcher.sh' (root credentions are
#                     needed, as well) from another console.
#
# Version:            1.0



# Forged GNOME application name
GSMON_APP_FILENAME="./gnome-system-m@nitor"

# Process name of forged GNOME application name
GSMON_APP_PROCNAME="gnome-system-m@nitor"

# Forged CONSOLE application name
HTOP_APP_FILENAME="./ht@p"

# Process name of forged CONSOLE application name
HTOP_APP_PROCNAME="ht@p"

# Data supplicant script name
PROCFS_REPLICATOR_SCR_FILENAME="./procfs_replicator.py"

# Process name of process generated by launch of data supplicant script
PROCFS_REPLICATOR_SCR_PROCNAME="procfs_replicator.py"

# Time intereal between data supplicant process lanch and time its deposit in a process tree is tangible
HTOP_SCR_LATENCY=18

# Forged dynamic library to let specific of GNOME application to work with </pr@c> instead of </proc>
FRG_LIB="/usr/lib/x86_64-linux-gnu/libgt@p-2.0.so.10.0.0"

# A symbolic link to a forged dynamic library
FRG_LIB_SYLINK="/usr/lib/x86_64-linux-gnu/libgt@p-2.0.so.10"

# Local and mirror directories cleaner
total_rollback()
{
	echo "Cleaning directory tree"

	sudo rm -f /pr@c
	sudo rm -f /s@s

	if [[ -L /pr@c  ]]; then
		echo "Symbolic link '/pr@c' was not deleted. Delete it manually"
	fi

	if [[ -L /s@s  ]]; then
		echo "Symbolic link '/s@s' was not deleted. Delete it manually"
	fi

	sudo rm -f $FRG_LIB

	if [[ -f $FRG_LIB  ]]; then
		echo "Library file "$FRG_LIB" was not deleted. Delete it manually"
	fi

	sudo rm -f $FRG_LIB_SYLINK

	if [[ -L $FRG_LIB_SYLINK  ]]; then
		echo "Symbolic link "$FRG_LIB_SYLINK" was not deleted. Delete it manually"
	fi

	rm -f $GSMON_APP_FILENAME

	if [[ -f $GSMON_APP_FILENAME  ]]; then
		echo "Application file link "$GSMON_APP_FILENAME" was not deleted. Delete it manually"
	fi

	rm -f $HTOP_APP_FILENAME

	if [[ -f $HTOP_APP_FILENAME  ]]; then
		echo "Application file link "$HTOP_APP_FILENAME" was not deleted. Delete it manually"
	fi

	chmod -x $PROCFS_REPLICATOR_SCR_FILENAME
}

# Script termination wrapper (needed for <total_rollback> is called from main line, and <accurately_exit> form functions)
accurately_exit()
{
	echo "Terminating scrpit '$0'"

	total_rollback

	echo "Scrpit '$0' terminated"

	exit -1
}

# Terminate data suplicant (presumebly launched earlier)
kill_those_posibly_started()
{
	sudo killall $PROCFS_REPLICATOR_SCR_PROCNAME > /dev/null 2>&1

	TEMP_LIB=`ps -fC $PROCFS_REPLICATOR_SCR_PROCNAME | grep $PROCFS_REPLICATOR_SCR_PROCNAME`

	if [[ -n $TEMP_LIB  ]]; then
		echo "Termination of "$PROCFS_REPLICATOR_SCR_PROCNAME" failed. Terminate manually. "
		accurately_exit
	else
		echo "Process "$PROCFS_REPLICATOR_SCR_PROCNAME" (is not active or) has been terminated"
	fi
}

# Forge GTK library <libgtop>, GNOME applicaiton <gnome-system-monitor>, and console interactive process viewer <htop>
accurate_preparation()
{
	# Point with symlink </pr@c> onto files (supposedly) produced by data supplicant Python script
	sudo ln -s /tmp/proc /pr@c

	# A symlink is vital for none of local apps or library will tolerate a different folder name
	if [[ ! -L "/pr@c" ]]; then

		echo "Symbolic link '/pr@c' has not been created "

		exit -1
	else
		echo "Symbolic link '/pr@c' has been created (or existed to the moment)"
	fi

	# Point with symlink </s@s> onto files (supposedly) produced by data supplicant Python script
	sudo ln -s /tmp/sys /s@s

	# A symlink is not vital, so don't exit ever if it's absent
	if [[ ! -L "/s@s" ]]; then

		echo "Symbolic link '/s@s' has not been created "

	else
		echo "Symbolic link '/s@s' has been created (or existed to the moment)"
	fi


	###################### LABRARY CREATION AND TANSFORMATION

	# Duplicate necessary library under specific name, needed for further transformations 
	sudo cp /usr/lib/x86_64-linux-gnu/libgtop-2.0.so.10.0.0  $FRG_LIB

	# Inability to duplicate is an arror
	if [[ ! -f "$FRG_LIB" ]]; then

		echo "Dynamic library "$FRG_LIB" has not been created "

		accurately_exit
	else
		echo "Dynamic library "$FRG_LIB" has been created (or existed to the moment)"
	fi

	# Make duplicated library to work with dedicated dir

	# A-transformation: replace all '/proc/' entries with '/pr@c/'
	sudo sed -i 's/\/proc\//\/pr@c\//g' $FRG_LIB

	# B-transformation: replace all '/sys/' entries with '/s@s/'
	sudo sed -i 's/\/sys\//\/s@s\//g' $FRG_LIB

	# C-transformation: replace all '/proc' entries with '/pr@c'
	sudo sed -i 's/\/proc/\/pr@c/g' $FRG_LIB

	# D-transformation: replace all '/sys' entries with '/s@s'
	sudo sed -i 's/\/sys/\/s@s/g' $FRG_LIB

	# Collect all initilized strings within duplicated library after above transform
	TEMP_LIB=`strings $FRG_LIB | grep /proc/`

	# Occurances of original directory name means an error
	if [[ -n $TEMP_LIB  ]]; then

		echo "Incorrect A-transformation of dynamic library "$FRG_LIB""

		accurately_exit
	fi

	# Collect all initilized strings within duplicated library after above transform
	TEMP_LIB=`strings $FRG_LIB | grep /proc`

	# Occurances of original directory name means an error
	if [[ -n $TEMP_LIB  ]]; then

		echo "Incorrect B-transformation of dynamic library "$FRG_LIB""

		accurately_exit
	fi

	# Collect all initilized strings within duplicated library after above transform
	TEMP_LIB=`strings $FRG_LIB | grep /sys/`

	# Occurances of original directory name means an error
	if [[ -n $TEMP_LIB  ]]; then

		echo "Incorrect C-transformation of dynamic library "$FRG_LIB""

		accurately_exit
	fi

	# Collect all initilized strings within duplicated library after above transform
	TEMP_LIB=`strings $FRG_LIB | grep /sys`

	# Occurances of original directory name means an error
	if [[ -n $TEMP_LIB  ]]; then

		echo "Incorrect D-transformation of dynamic library "$FRG_LIB""

		accurately_exit
	fi



	# Make a symbolic link to point onto duplicated (and altered) library
	sudo ln -s $FRG_LIB  $FRG_LIB_SYLINK

	# Inability to make a link means an error
	if [[ ! -L "$FRG_LIB_SYLINK" ]]; then

		echo "Symbolic link "$FRG_LIB_SYLINK" has not been created "

		accurately_exit
	else
		echo "Symbolic link "$FRG_LIB" has been created (or existed to the moment)"
	fi

	# Forged library is ready, and is pointed to by a symbolic link



	###################### APPLICATIONS COPYING AND TRANSFORMATIONS

	# Prepare a local copy of GNOME application for further transformations 
	cp `which gnome-system-monitor` $GSMON_APP_FILENAME

	# Absence of local copy of GNOME application upon copying is an error
	if [[ ! -f $GSMON_APP_FILENAME ]]; then

		echo "Application file $GSMON_APP_FILENAME file has not been created "

		accurately_exit
	else
		echo "Application file $GSMON_APP_FILENAME file has been created (or existed to the moment)"
	fi

	# Make the local copy of GNOME application to depend on forged lib
	sed -i 's/libgtop/libgt@p/g' $GSMON_APP_FILENAME

	# Collect all dependencies of local copy of GNOME application after above transform
	TEMP_LIB=`ldd $GSMON_APP_FILENAME | grep libgt@ | awk '{print $3}'`

	# Dependency on original library is an error
	if [[ $TEMP_LIB != "/usr/lib/x86_64-linux-gnu/libgt@p-2.0.so.10" ]]; then

		echo "Incorrect A-transformation of application $GSMON_APP_FILENAME"

		accurately_exit
	fi

	# Make the local copy of GNOME application to look into dedicated dir
	sed -i 's/\/proc\//\/pr@c\//g' $GSMON_APP_FILENAME

	# Collect all initilized strings within local copy of GNOME application after above transform
	TEMP_LIB=`strings ./gnome-system-m@nitor | grep /proc`

	# Occurances of original directory name is an error
	if [[ -n $TEMP_LIB  ]]; then

		echo "Incorrect B-transformation of application $GSMON_APP_FILENAME"

		accurately_exit
	fi

	# Prepare a local copy of CONSOLE application for further transformations 
	cp `which htop` $HTOP_APP_FILENAME

	# Absence of local copy of CONSOLE application upon copying is an error
	if [[ ! -f "$HTOP_APP_FILENAME" ]]; then

		echo "Application file "$HTOP_APP_FILENAME" file has not been created "

		accurately_exit
	else
		echo "Application file "$HTOP_APP_FILENAME" file has been created (or existed to the moment)"
	fi

	# Make the local copy of COLNSOLE application to look into dedicated dir
	sed -i 's/\/proc\//\/pr@c\//g' $HTOP_APP_FILENAME
	sed -i 's/\/proc/\/pr@c/g' $HTOP_APP_FILENAME

	# Collect all initilized strings within local copy of CONSOLE application after above transform
	TEMP_LIB=`strings $HTOP_APP_FILENAME | grep /proc`

	# Occurances of original directory name is an error
	if [[ -n $TEMP_LIB  ]]; then

		echo "Incorrect A-,B-transformation of application "$HTOP_APP_FILENAME""

		accurately_exit
	fi

	# Specific GNOME and CONSOLE applications are ready and are kept in local folder
}

# Start data supplicant Python script
start_replicating_script()
{
	# Self-explanatory
	echo "Starting script "$PROCFS_REPLICATOR_SCR_FILENAME" ..."

	# Make executable of a script code (which is not executable by default to prevent users launching it as standalone script)
	chmod +x $PROCFS_REPLICATOR_SCR_FILENAME

	# Start content replicator suppressing any output
	$PROCFS_REPLICATOR_SCR_FILENAME >/dev/null 2>&1 &

	# Let the Python start the script
	sleep $HTOP_SCR_LATENCY

	# Check if the script has initiated eponymous process
	TEMP_LIB=`ps -fC $PROCFS_REPLICATOR_SCR_PROCNAME | grep $PROCFS_REPLICATOR_SCR_FILENAME`

	# Handle 'initiated' and 'not initiated' cases
	if [[ -z $TEMP_LIB  ]]; then

		echo "Script "$PROCFS_REPLICATOR_SCR_FILENAME" didn't start "

		accurately_exit
	else
		echo "Script "$PROCFS_REPLICATOR_SCR_FILENAME" was staretd "
	fi
}

# Check if the data supplicant Python scripts do supply a data 
verify_produced_content()
{
	echo "Checking consistency of "$PROCFS_REPLICATOR_SCR_PROCNAME" process..."

	# TODO: check if '/pr@c/1/task/1/cmdline' is really needed
	if [[ ! -f "/pr@c/loadavg" || ! -f "/pr@c/vmstat" || ! -f "/pr@c/stat" || ! -f "/pr@c/meminfo" || ! -f  "/pr@c/1/task/1/cmdline" ]]; then

		echo "No content produced by "$PROCFS_REPLICATOR_SCR_PROCNAME" process was detected"

		accurately_exit
	else
		echo "Process "$PROCFS_REPLICATOR_SCR_PROCNAME" operates correcty. It's OK now to start the "$GSMON_APP_FILENAME" and "$HTOP_APP_FILENAME""
	fi
}

# Cyclicaly launch first parameter (as bash command) once appeares to be not launched
respawn_the_gnome_app()
{
	# Eternally..
	while [ true ]
	do
		# Be idle for second or so to not overload current process
		sleep 1

		# ${1:2} is $1 without first 2 characters, i.e. without "./"
		if [ -z `ps -fC ${1:2} | grep $1` ] 
		then
			# From now on this app. will automaticaly restart any time it crashes (due an internal error) or correclty terminates
			$1 >/dev/null 2>&1

			# Use 'q' or 'Ctrl+C' in HTOP's console to stop it
			echo "$1 is not running. (Re)starting"
		fi
	done
}

# Cyclicaly launch first parameter (as bash command) once appeares to be not launched
respawn_the_console_app()
{
	# Eternally..
	while [ true ]
	do
		# Be idle for second or so to not overload current process
		sleep 1

		# ${1:2} is $1 without first 2 characters, i.e. without "./"
		if [ -z `ps -fC ${1:2} | grep $1` ] 
		then
			# From now on this app. will automaticaly restart any time it crashes (due an internal error) or correclty terminates
			$1

			# Use 'q' or 'Ctrl+C' in HTOP's console to stop it
			echo "$1 is not running. (Re)starting"
		fi
	done
}

# Start first GNOME and then - CONSOLE applications
start_applications()
{
	echo "Starting an application "$GSMON_APP_FILENAME" in 'auto-restart' mode"

	# Detached shell is needed to not block current thread, all output is suppressed to not spoil <ht@p> view

	# respawn_the_gnome_app $GSMON_APP_FILENAME >/dev/null 2>&1 & 

	echo "Starting aplication "$HTOP_APP_FILENAME" in 'auto-restart' mode"

	respawn_the_console_app $HTOP_APP_FILENAME
}



#################### PROGRAM ENTRY POINT

# To prevent mess in process tree terminate 'procfs_replicator.py' if already started
kill_those_posibly_started

# To prevent mess in local dir and in root dir clean them before using agan
total_rollback

# Prepare root folder, create forged 'libgtop' in '/usr/lib/x86_64-linux-gnu/' and executables 'ht@p', 'gnome-system-m@nitor'
accurate_preparation

# Launch a script (data-replicant) which will replicate some of '/proc' and '/sys' in '/pr@c' and '/s@s'
start_replicating_script

# Check if data-replicant script was stqarted and works correclty
verify_produced_content

# Launch 'ht@p', 'gnome-system-m@nitor'
start_applications

# If we're here then somebody wnats us to stop all the activity
kill_those_posibly_started

# Clean after ourselves (where ever it's possioble) before quit
total_rollback
